import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.widgets import Slider, TextBox

# --- 初期パラメータ ---
INIT_STIFFNESS = 100.0  # バネ定数（硬さ）
INIT_DAMPING = 2.5      # 減衰係数（揺れの収まりやすさ）
INIT_MASS = 2.0          # 質点の質量

# --- パラメータ調整 ---
DT = 0.02        # 時間刻み (秒)
STEPS = 10       # 1フレームあたりの計算ステップ数（挙動安定化のため）
GRAVITY = np.array([0, -9.8]) # 重力加速度
REST_LEN = 0.5    # バネの自然長

# --- グローバル変数（現在値） ---
params = {
    'stiffness': INIT_STIFFNESS,
    'damping': INIT_DAMPING,
    'mass': INIT_MASS
}
# --- 構造体の生成 ---
# 3x3 の格子状の質点を作成
nx, ny = 4, 4
x = np.linspace(1, 3, nx)
y = np.linspace(5, 7, ny)
X, Y = np.meshgrid(x, y)
# 質点の位置 [N, 2]
positions = np.stack([X.ravel(), Y.ravel()], axis=1)
# 質点の速度 [N, 2]
velocities = np.zeros_like(positions)
n_points = len(positions)

# バネ接続リストの作成（構造解析のメッシュ生成に近い処理）
springs = []
for i in range(n_points):
    r, c = divmod(i, nx)
    # 右隣との接続
    if c < nx - 1: springs.append((i, i + 1))
    # 上との接続
    if r < ny - 1: springs.append((i, i + nx))
    # 斜め接続（せん断変形への抵抗）
    if c < nx - 1 and r < ny - 1: springs.append((i, i + nx + 1))
    if c > 0 and r < ny - 1: springs.append((i, i + nx - 1))

springs = np.array(springs)

# --- 物理計算カーネル ---
def update_physics(pos, vel, drag_idx, mouse_pos):
    # 外力（重力）の適用
    forces = np.tile(GRAVITY * params['mass'], (n_points, 1))
    
    # マウスインタラクション（外部入力）
    if drag_idx is not None:
        # マウス位置へ引っ張る力（強いバネとしてモデル化）
        diff = mouse_pos - pos[drag_idx]
        forces[drag_idx] += diff * 300.0
        vel[drag_idx] *= 0.1    # ドラッグ中は暴れないよう減速

    # バネ力
    p1 = pos[springs[:, 0]]
    p2 = pos[springs[:, 1]]

    # ベクトルと距離
    diff = p2 - p1
    dist = np.linalg.norm(diff, axis=1, keepdims=True)
    dist[dist < 1e-6] = 1e-6
    
    # フックの法則 + 簡易的な非線形性（対角線は長さを変えるなど工夫可能だが今回は均一）
    current_rest = REST_LEN * np.ones_like(dist)
    # 斜めバネは自然長を√2倍にする簡易補正
    # (本来は初期形状から計算すべきだがコード簡略化のため)
    is_diagonal = (np.abs(springs[:, 0] - springs[:, 1]) != 1) & \
                  (np.abs(springs[:, 0] - springs[:, 1]) != nx)
    current_rest[is_diagonal] *= 1.414 

    displacement = dist - current_rest
    direction = diff / dist
    
    force_mag = params['stiffness'] * displacement
    
    # 作用・反作用の法則で力を分配
    # numpy.add.at は重複インデックスへの加算を高速に行う（FEMのアセンブリに近い）
    np.add.at(forces, springs[:, 0], force_mag * direction)
    np.add.at(forces, springs[:, 1], -force_mag * direction)

    # ダンピング（粘性抵抗）
    forces -= vel * params['damping']

    # オイラー法による積分 (簡易的だが実装が容易)
    acc = forces / params['mass']
    vel += acc * DT
    pos += vel * DT

    # --- 境界条件（壁・床との衝突判定） ---
    # 床
    hit_floor = pos[:, 1] < 0
    pos[hit_floor, 1] = 0
    vel[hit_floor, 1] *= -1.0  # 反発係数
    vel[hit_floor, 0] *= 0.5   # 摩擦

    # 壁
    hit_left = pos[:, 0] < 0
    pos[hit_left, 0] = 0
    vel[hit_left, 0] *= -0.6
    
    hit_right = pos[:, 0] > 6
    pos[hit_right, 0] = 6
    vel[hit_right, 0] *= -0.6

    return pos, vel

# --- インタラクション設定 ---
# --- GUIと描画のセットアップ ---
fig = plt.figure(figsize=(9, 7))
# 上部にシミュレーション画面、下部にコントロールパネル
ax_sim = fig.add_axes([0.1, 0.45, 0.8, 0.5]) # [left, bottom, width, height]
ax_sim.set_xlim(-1, 7)
ax_sim.set_ylim(-1, 8)
ax_sim.set_aspect('equal')
ax_sim.set_title("Interactive Material Lab")
ax_sim.grid(True, linestyle='--', alpha=0.3)

lines, = ax_sim.plot([], [], 'o-', lw=2, ms=6, color='#0078D7')
ax_sim.axhline(0, color='black', lw=2)

# --- GUIウィジェットの配置 ---
# 配置座標: [left, bottom, width, height]
y_base = 0.3
h_step = 0.08
ax_color = 'lightgoldenrodyellow'

# 1. Stiffness (剛性)
ax_k_slider = fig.add_axes([0.15, y_base, 0.45, 0.03], facecolor=ax_color)
ax_k_text   = fig.add_axes([0.7, y_base, 0.15, 0.03])
s_stiffness = Slider(ax_k_slider, 'Stiffness', 10.0, 5000.0, valinit=INIT_STIFFNESS)
t_stiffness = TextBox(ax_k_text, '', initial=str(INIT_STIFFNESS))

# 2. Damping (減衰)
y_base -= h_step
ax_d_slider = fig.add_axes([0.15, y_base, 0.45, 0.03], facecolor=ax_color)
ax_d_text   = fig.add_axes([0.7, y_base, 0.15, 0.03])
s_damping   = Slider(ax_d_slider, 'Damping', 0.0, 20.0, valinit=INIT_DAMPING)
t_damping   = TextBox(ax_d_text, '', initial=str(INIT_DAMPING))

# 3. Mass (質量)
y_base -= h_step
ax_p_slider = fig.add_axes([0.15, y_base, 0.45, 0.03], facecolor=ax_color)
ax_p_text   = fig.add_axes([0.7, y_base, 0.15, 0.03])
s_mass  = Slider(ax_p_slider, 'Mass', 0.0, 10000.0, valinit=INIT_MASS)
t_mass  = TextBox(ax_p_text, '', initial=str(INIT_MASS))

# --- コールバック関数 (同期処理) ---
# スライダーを動かしたとき
def update_from_slider(val):
    params['stiffness'] = s_stiffness.val
    params['damping'] = s_damping.val
    params['mass'] = s_mass.val
    
    # テキストボックスの表示も更新（無限ループ防止のためイベントを切ってセットできればベストだが簡略化）
    # ※ Matplotlibの仕様上、setValueでイベントが発火し合うのを防ぐ工夫が必要ですが、
    #    今回は単純化のため、テキストボックスへの書き戻しはユーザー入力時のみ反映させます。
    #    （スライダー操作中は数値を目視確認できるため）
    pass 

s_stiffness.on_changed(update_from_slider)
s_damping.on_changed(update_from_slider)
s_mass.on_changed(update_from_slider)

# テキストボックスに入力したとき
def submit_stiffness(text):
    try:
        val = float(text)
        s_stiffness.set_val(val) # スライダーも更新
        params['stiffness'] = val
    except ValueError:
        pass

def submit_damping(text):
    try:
        val = float(text)
        s_damping.set_val(val)
        params['damping'] = val
    except ValueError:
        pass

def submit_mass(text):
    try:
        val = float(text)
        s_mass.set_val(val)
        params['mass'] = val
    except ValueError:
        pass

t_stiffness.on_submit(submit_stiffness)
t_damping.on_submit(submit_damping)
t_mass.on_submit(submit_mass)

# --- インタラクション ---
is_dragging = False
drag_idx = None
current_mouse_pos = np.zeros(2)

def on_click(event):
    global is_dragging, drag_idx
    if event.button == 1 and event.inaxes:
        mouse_p = np.array([event.xdata, event.ydata])
        dists = np.linalg.norm(positions - mouse_p, axis=1)
        nearest = np.argmin(dists)
        if dists[nearest] < 0.8:    # クリック判定半径
            is_dragging = True
            drag_idx = nearest

def on_release(event):
    global is_dragging, drag_idx
    is_dragging = False
    drag_idx = None

def on_move(event):
    if event.inaxes:
        current_mouse_pos[:] = [event.xdata, event.ydata]


fig.canvas.mpl_connect('button_press_event', on_click)
fig.canvas.mpl_connect('button_release_event', on_release)
fig.canvas.mpl_connect('motion_notify_event', on_move)


def init():
    lines.set_data([], [])
    return lines,

def animate(frame):
    global positions, velocities
    for _ in range(STEPS):
        positions, velocities = update_physics(
            positions, velocities, 
            drag_idx if is_dragging else None, 
            current_mouse_pos
        )
    
    x_list = []
    y_list = []
    for s in springs:
        x_list.extend([positions[s[0], 0], positions[s[1], 0], np.nan])
        y_list.extend([positions[s[0], 1], positions[s[1], 1], np.nan])
        
    lines.set_data(x_list, y_list)

    # 材質に応じて色を変える演出
    if params['stiffness'] < 300:
        lines.set_color('#32CD32') # Green (Slime)
    elif params['stiffness'] > 3000:
        lines.set_color('#606060') # Gray (Hard)
    else:
        lines.set_color('#0078D7') # Blue (Standard)

    return lines,

ani = animation.FuncAnimation(fig, animate, init_func=init, interval=20, blit=True)
plt.grid(True, linestyle='--', alpha=0.3)
plt.show()